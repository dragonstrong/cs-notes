# 1.redis
## 1.1 springboot整合redis
### 1.1.1引入依赖
```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```
redis的自动配置
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711163193781-a4ac2e7f-8941-4452-be75-96c2949105a6.png#averageHue=%23868970&clientId=u06e73f37-3b5d-4&from=paste&height=372&id=sSf3U&originHeight=372&originWidth=667&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57593&status=done&style=none&taskId=ude87b938-8a74-4ca0-bfd7-df6de7103c2&title=&width=667)
### 1.1.2配置redis
```xml
spring:
  redis:
    host: 192.168.30.128
    port: 6379
    password: 181181@Lq
```
### 1.1.3 使用RedisTemplate或StringRedisTemplate
## 1.2 数据类型
参考：[https://redis.io/docs/data-types/](https://redis.io/docs/data-types/)
中文网： [https://www.redis.net.cn/](https://www.redis.net.cn/)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711335301621-db453332-c90f-4643-bcbb-0f8a9e6f7a54.png#averageHue=%23f5f7fa&clientId=u22f3bf3b-d0c5-4&from=paste&height=364&id=u860bbae8&originHeight=364&originWidth=278&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15639&status=done&style=none&taskId=u939d22c7-4143-4779-ac10-1fb1425e829&title=&width=278)

- **redis自身是一个Map，其中所有的数据都是采用key:value的形式储存。**
- **数据类型指的是存储的数据的类型，也就是value部分的类型，key部分永远都是字符串。**
- ![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711335015464-801e194d-e062-4128-88c5-3561450922bb.png#averageHue=%23f4c3c2&clientId=u22f3bf3b-d0c5-4&from=paste&height=401&id=ub25ab400&originHeight=401&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33283&status=done&style=none&taskId=u43bc4120-0738-4196-a9a8-208d0993ce3&title=&width=490)
- 查命令：[https://redis.io/commands/](https://redis.io/commands/)
- ![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711356991115-cadd31f3-273b-4543-80a5-197a86e86d96.png#averageHue=%23daba8c&clientId=u01985808-0776-4&from=paste&height=688&id=u8ee9e50d&originHeight=688&originWidth=1225&originalType=binary&ratio=1&rotation=0&showTitle=false&size=105172&status=done&style=none&taskId=u9a414365-4acf-4b39-9f9e-67f38247d63&title=&width=1225)
### 1.2.1 String
说明：**一般先将java对应转换为json String再存进redis，方便其他语言读取，因此String类型用得比较多。**
#### 1.2.1.1 命令
```bash
set math 1 #设置键值对 math -> 1
get math  #获取
del math  #删除
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711356704187-3e3f0054-35c0-42f9-bae4-9c6ace148395.png#averageHue=%23f4f3f2&clientId=u01985808-0776-4&from=paste&height=88&id=uab15b758&originHeight=88&originWidth=413&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4591&status=done&style=none&taskId=u611d089b-ef33-4736-820e-23e3574538f&title=&width=413)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711356790878-32086999-326d-4c5b-b0fc-043100a118b0.png#averageHue=%232b2928&clientId=u01985808-0776-4&from=paste&height=148&id=ub651ad29&originHeight=148&originWidth=240&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4759&status=done&style=none&taskId=uc03df05b-3408-406f-b501-b89c678c10e&title=&width=240)
#### 1.2.1.2 接口调用
```java
ValueOperations<String,String> ops=stringRedisTemplate.opsForValue();
ops.set("math","100");  // 设置键值对 math -> 100
log.info(ops.get("math"));   // 获取
String s=ops.getAndDelete("math"); // 获取并删除
```
### 1.2.2 Hash
[https://redis.io/docs/data-types/hashes/](https://redis.io/docs/data-types/hashes/)
value是一个map
#### 1.2.2.1 命令
key=nginx，value为一个map示例：
```bash
hset nginx a 1 # 增加元素
hget nginx a   #获取单个元素的value
hgetall nginx  #获取整个map
del nginx     #删除整个map
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711339538314-6fbbaa13-fc54-457f-b1e1-f9cfa2f43979.png#averageHue=%2322201e&clientId=u22f3bf3b-d0c5-4&from=paste&height=203&id=u26f4df33&originHeight=203&originWidth=283&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10773&status=done&style=none&taskId=u3f34fb04-5e65-4131-8a48-29c57b356f1&title=&width=283)
#### 1.2.2.2 接口调用
value为Map
```java
// 插入
@Autowired
private StringRedisTemplate stringRedisTemplate;
HashOperations<String,String,String> ops=stringRedisTemplate.opsForHash();
Arrays.asList(1,2,3).stream().forEach(element->{
    ops.put("nginx",String.valueOf(element),"aa"+element);
});

// 获取
Map<String,String> map=ops.entries("nginx");

// 删除
map.keySet().forEach(element->{
            ops.delete("nginx",element);
        });  // 逐个删除，当map里元素为0时，key为"nginx"的键值对不存在
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711339199111-a35342a9-1805-4439-a165-aa7f8f666266.png#averageHue=%23f7f3f2&clientId=u22f3bf3b-d0c5-4&from=paste&height=165&id=udf4d8ad1&originHeight=165&originWidth=598&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14812&status=done&style=none&taskId=u575b9cc0-a963-4094-a96d-3281bc25112&title=&width=598)
### 1.2.3 List
[https://redis.io/docs/data-types/lists/](https://redis.io/docs/data-types/lists/)
底层数据结构是双向链表，往左往右插都行。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711359263885-88429cce-7ec4-47f5-941c-be0986e95929.png#averageHue=%23fcfbf9&clientId=u01985808-0776-4&from=paste&height=774&id=u10ce73ee&originHeight=774&originWidth=2077&originalType=binary&ratio=1&rotation=0&showTitle=false&size=569012&status=done&style=none&taskId=u6e559994-780e-4fe1-9de7-47bbd933535&title=&width=2077)
#### 1.2.3.1 命令
```bash
lpush list1 1 2 3 4 #从左插
lrange list1 0 -1  #从左数，列出list1所有元素， 后两个参数为始末下标，只有lrange没有rrange
lpush list1 1 2 3 4 #从右插
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711364252810-c8c32594-f760-4028-8d5f-1e4282cbe2bf.png#averageHue=%23222120&clientId=uf87b76cf-36fd-4&from=paste&height=220&id=ubb4fe0a9&originHeight=220&originWidth=330&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9610&status=done&style=none&taskId=u84085c37-5adc-4185-989c-6a26c791027&title=&width=330)
```bash
lpop list1 2 #从左弹出2个元素， 假设list1之前为[4,3,2,1] ，执行之后为[2,1],不加最后一个参数默认弹出1个元素
rpop list1 2 #从右弹出2个元素
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711364648329-419f1afe-db8a-428d-8e84-aa174682aef0.png#averageHue=%231f1e1d&clientId=uf87b76cf-36fd-4&from=paste&height=173&id=ua0da6aeb&originHeight=173&originWidth=285&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6779&status=done&style=none&taskId=ue773de91-4c38-400e-80c1-906f616d5a1&title=&width=285)
```bash
lindex list1 1 #列出下标为1的元素（从左往右）
llen list1  #获取list1中元素的个数
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711365113453-2e06b39b-9c67-419e-b72b-29126c4f9a22.png#averageHue=%231f1e1d&clientId=uf87b76cf-36fd-4&from=paste&height=142&id=u250cd342&originHeight=142&originWidth=275&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5981&status=done&style=none&taskId=ufa7012b9-23e9-4219-a903-d51a76d3ccf&title=&width=275)
```bash
lrem list1 2 3 #删除2个3（从左往右）
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711365806904-58f5adcf-1b7d-4cac-ad05-ea576c985734.png#averageHue=%231e1d1c&clientId=uf87b76cf-36fd-4&from=paste&height=274&id=u3a86627e&originHeight=274&originWidth=326&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8672&status=done&style=none&taskId=ub35a3837-99c2-4eb5-9e3a-2f717a0a631&title=&width=326)
```bash
ltrim list1 1 3  #截取下标1-3的元素再赋值给list1
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711365948388-ad11761f-12a6-4ba4-be64-b4da7c24e279.png#averageHue=%231f1e1e&clientId=uf87b76cf-36fd-4&from=paste&height=200&id=ubfa68c7e&originHeight=200&originWidth=301&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7354&status=done&style=none&taskId=u940ebacc-38af-42a1-8e48-d9bb9fae753&title=&width=301)
```bash
rpoplpush list1 list2 #将list1的最右边的元素弹出往list2最左边塞
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711366238740-bbf638a8-4208-469a-a59f-70d8b05defbc.png#averageHue=%23222120&clientId=uf87b76cf-36fd-4&from=paste&height=307&id=uf714a927&originHeight=307&originWidth=300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12182&status=done&style=none&taskId=u306807d3-052f-47ad-b01c-a3106efbdb4&title=&width=300)
```bash
lset list2 1 9  #将list2下标为1的元素设置为9
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711368393699-91dd62bc-57e4-40c8-b67e-a52668c4cae8.png#averageHue=%2321201f&clientId=uf87b76cf-36fd-4&from=paste&height=216&id=ua78fcdc9&originHeight=216&originWidth=293&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7893&status=done&style=none&taskId=u61ea1307-0c16-4613-a50c-aa01732186f&title=&width=293)
```bash
linsert list2 before 9 10  #在9前面插入10
linsert list2 before 9 10  #在9后面插入10
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711368561204-a9343ad7-6eec-4a6d-8a29-e75c2a03f762.png#averageHue=%231e1d1d&clientId=uf87b76cf-36fd-4&from=paste&height=232&id=u78156de0&originHeight=232&originWidth=349&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9013&status=done&style=none&taskId=u851f1bff-acd4-412f-854c-5a51767a9eb&title=&width=349)
#### 1.2.3.2 接口调用
```java
ListOperations<String,String> ops=stringRedisTemplate.opsForList();
ops.leftPushAll("list1","1","2","3","4");  // 左插 ["4","3","2","1"]
List<String> list1=ops.range("list1",0,-1); // 获取
ops.leftPop("list1");  // 最左边弹出一个元素  -> ["3","2","1"]
ops.set("list1",1,"ab");  // 设置下标为1的元素  ["3","ab","1"]
ops.remove("list1",2,"1"); // 移除2个1  -> ["3","ab"]
```
### 1.2.4 Set
[https://redis.io/docs/data-types/sets/](https://redis.io/docs/data-types/sets/)
#### 1.2.4.1 命令
```bash
sadd set1 1 2 3 4 # 往set1中添加元素1~4，自动去重
smembers set1 #遍历集合set1
sismember set1 2 #判断元素2是否在set1中
srem set1 4  #删除元素4
scard set1 #获取set1中元素个数
srandmember set1 2 #从set1中随机展示2个元素
del set1 #删除整个key (set1)

#集合间操作
sinter set1 set2 #交集
sunion set1 set2  #并集
sdiff set1 set2  #补集（set1有set2无）
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711350740399-252ddec8-23b8-4e86-aa7c-31db6b5ebc64.png#averageHue=%2321201f&clientId=uf9c08dc4-4acd-4&from=paste&height=544&id=u678025ea&originHeight=544&originWidth=697&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45448&status=done&style=none&taskId=ub49139d9-e3ce-4d85-aad9-b83b81b0cf6&title=&width=697)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711350310682-bae2d1ea-74b8-4e3a-821e-d5a6f7cc85dc.png#averageHue=%23f7f2f1&clientId=uf9c08dc4-4acd-4&from=paste&height=174&id=u22e7e5d7&originHeight=174&originWidth=581&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12251&status=done&style=none&taskId=u415b0b15-b8de-440f-b443-bbbf54520f6&title=&width=581)
集合间操作：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711352292201-d2bbc95c-69fc-45e3-9195-fca50bf2b275.png#averageHue=%23252322&clientId=uf9c08dc4-4acd-4&from=paste&height=227&id=ucaefd6b6&originHeight=227&originWidth=346&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12112&status=done&style=none&taskId=uba675c3a-130f-4b4a-9af0-2db35fabe3c&title=&width=346)
#### 1.2.4.2 接口调用
```java
SetOperations<String,String> ops=stringRedisTemplate.opsForSet();
ops.add("set1","1","2","3"); // 新建集合set1并插入元素1 2 3
ops.add("set2","2","3","4");
Set<String> set1=ops.members("set1");  // 获取集合set1
Set<String> common=ops.intersect("set1","set2"); // 交集 {2,3}
Set<String> union=ops.union("set1","set2"); // 并集   {1,2,3,4}
Set<String> diff=ops.difference("set1","set2"); // 差集（set1中有set2中没有）-> {1}
```
### 1.2.5 Sorted Set
#### 1.2.5.1 命令
#### 1.2.5.2 接口调用


## 1.3 示例
说明：**一般先将java对象转换为json String再存进redis，方便其他语言读取**，因此**用的最多的是StringRedisTemplate.opsForValue()**
```java
/**
     * @description: p138 二级三级分类数据
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonByDB(){
        Map<String, List<Catalog2Vo>> map=null;  // 结果
        // 找一级分类
        List<CategoryEntity> categoryEntityList=getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid",0));
        if (categoryEntityList!=null){
            // 对每一个一级分类找二级分类
            // 封装成map   key=一级分类的catId  value=List<Catalog2Vo>
            map=categoryEntityList.stream().collect(Collectors.toMap(k->{
                return k.getCatId().toString();
            },v->{
                // 找v的二级分类列表
                List<Catalog2Vo> catalog2VoList=null;
                List<CategoryEntity> category2Entities=getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid",v.getCatId()));
                if (category2Entities!=null){
                    // 将category2Entities封装成List<Catalog2Vo>
                    // 先找3级子分类列表
                    catalog2VoList=category2Entities.stream().map(l2->{
                        List<CategoryEntity> category3Entities=getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid",l2.getCatId()));
                        List<Catalog2Vo.Category3Vo> category3VoList=null;
                        if (category3Entities!=null){
                            category3VoList=category3Entities.stream().map(l3->{
                                Catalog2Vo.Category3Vo catalog3Vo=new Catalog2Vo.Category3Vo(l2.getCatId().toString(),l3.getCatId().toString(),l3.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                        }
                        Catalog2Vo catalog2Vo=new Catalog2Vo(l2.getParentCid().toString(),category3VoList,l2.getCatId().toString(),l2.getName());
                        return catalog2Vo;
                    }).collect(Collectors.toList());
                }
                return catalog2VoList;
            }));
        }
        return map;
    }


    /**
     * @description: p138 二级三级分类数据(使用redis)
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonUseRedis(){
        ValueOperations<String ,String > ops=stringRedisTemplate.opsForValue();
        // 先查redis缓存，没有再从mysql封装
        String catalogJson=stringRedisTemplate.opsForValue().get(CATALOG_JSON);
        // 查数据库
        if (catalogJson==null){
            log.info("缓存中没有二级三级分类数据，开始查询数据库");
            Map<String, List<Catalog2Vo>> map=getCatalogJsonByDB();
            // 写入redis (先转为json String, 方便跨语言和平台，直接写入java数据结构其他语言获取不方便)
            log.info("缓存中有二级三级分类数据，直接返回");
            ops.set(CATALOG_JSON,JSON.toJSONString(map));
            return map;
        }
        // 缓存里有直接返回
        Map<String, List<Catalog2Vo>> map=JSON.parseObject(catalogJson,new TypeReference<Map<String, List<Catalog2Vo>>>(){});
        return map;
    }
```

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711429140671-1a0cae2a-25a7-459b-971b-3c6fde61d68f.png#averageHue=%23f7f5f2&clientId=u0c65e150-8b30-4&from=paste&height=484&id=u4a5020ef&originHeight=484&originWidth=1596&originalType=binary&ratio=1&rotation=0&showTitle=false&size=93226&status=done&style=none&taskId=u17477670-2a7d-43c6-a648-66bc30236a7&title=&width=1596)

# 2.本地锁
## 2.1 加本地锁
不加锁
```java
   /**
     * @description: p138 二级三级分类数据(使用redis)
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonUseRedis(){

            ValueOperations<String ,String > ops=stringRedisTemplate.opsForValue();
            // 先查redis缓存，没有再从mysql封装
            String catalogJson=stringRedisTemplate.opsForValue().get(CATALOG_JSON);
            // 查数据库
            if (catalogJson==null){
                log.info("缓存中没有二级三级分类数据，开始查询数据库");
                Map<String, List<Catalog2Vo>> map=getCatalogJsonByDB();
                // 写入redis (先转为json String, 方便跨语言和平台，直接写入java数据结构其他语言获取不方便)
                ops.set(CATALOG_JSON,JSON.toJSONString(map));
                return map;
            }
            // 缓存里有直接返回
            log.info("缓存中有二级三级分类数据，直接返回");
            Map<String, List<Catalog2Vo>> map=JSON.parseObject(catalogJson,new TypeReference<Map<String, List<Catalog2Vo>>>(){});
            return map;
        }
}
```
2万并发下来，不止查一遍数据库
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711429096590-bc4dea84-759d-4520-9646-79a4e980dde1.png#averageHue=%23353332&clientId=u3bde19c0-8494-4&from=paste&height=252&id=u6c8d765e&originHeight=252&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&size=98519&status=done&style=none&taskId=u09a09d05-6eb1-42b0-b401-1c1e016d814&title=&width=1137)


加锁：**只要是一把锁，就能锁住需要这个锁的所有线程**
```java
   /**
     * @description: p138 二级三级分类数据(使用redis)
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonUseRedis(){
        synchronized (this){  // 加锁
            ValueOperations<String ,String > ops=stringRedisTemplate.opsForValue();
            // 先查redis缓存，没有再从mysql封装
            String catalogJson=stringRedisTemplate.opsForValue().get(CATALOG_JSON);
            // 查数据库
            if (catalogJson==null){
                log.info("缓存中没有二级三级分类数据，开始查询数据库");
                Map<String, List<Catalog2Vo>> map=getCatalogJsonByDB();
                // 写入redis (先转为json String, 方便跨语言和平台，直接写入java数据结构其他语言获取不方便)
                ops.set(CATALOG_JSON,JSON.toJSONString(map));
                return map;
            }
            // 缓存里有直接返回
            log.info("缓存中有二级三级分类数据，直接返回");
            Map<String, List<Catalog2Vo>> map=JSON.parseObject(catalogJson,new TypeReference<Map<String, List<Catalog2Vo>>>(){});
            return map;
        }
    }

}
```
2万并发下来，只查一遍数据库
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711428913456-84ec516b-7ea9-4a87-8f6a-dc067e49ab2c.png#averageHue=%2333312f&clientId=u8ab9db17-71a1-4&from=paste&height=338&id=u3c62bee7&originHeight=338&originWidth=1294&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126628&status=done&style=none&taskId=u433c41df-184a-4a4f-92c4-b8429430c56&title=&width=1294)
## 2.2 本地锁在分布式下的问题
将上述加锁代码在分布式环境测试，由于**本地锁（ synchronized, JUC(LOCK) ）只能锁住当前进程，所以如果gulimall-product分布在3个实例上，并发负载均衡到每个实例都得查一遍数据库**。故总共查了3遍数据库，无法实现只查1遍数据库。
```java
import java.util.concurrent.locks.*;  // JUC下本地锁
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711512999787-eaddc420-8db5-4412-a866-c29ef1c23e98.png#averageHue=%23514d41&clientId=ua382c76d-c2f8-4&from=paste&height=589&id=u7299b31c&originHeight=589&originWidth=717&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67798&status=done&style=none&taskId=u8b200a4c-6c34-48ee-86dc-bd9321dc930&title=&width=717)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711451282051-fc45bddb-355a-4c5e-a9e2-f42e26744f55.png#averageHue=%23aabc65&clientId=u7c3c816c-fe7a-4&from=paste&height=285&id=ub8d54abe&originHeight=285&originWidth=622&originalType=binary&ratio=1&rotation=0&showTitle=false&size=156818&status=done&style=none&taskId=u02b7ca03-22e0-4999-bf65-d7874c85fcc&title=&width=622)

从数据库查：
```java
/**
     * @description: p138 二级三级分类数据
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonByDB() {
        log.info("查询了数据库");
        Map<String, List<Catalog2Vo>> map = null;  // 结果
        // 找一级分类
        List<CategoryEntity> categoryEntityList = getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", 0));
        if (categoryEntityList != null)
        {
            // 对每一个一级分类找二级分类
            // 封装成map   key=一级分类的catId  value=List<Catalog2Vo>
            map = categoryEntityList.stream().collect(Collectors.toMap(k -> {
                return k.getCatId().toString();
            }, v -> {
                // 找v的二级分类列表
                List<Catalog2Vo> catalog2VoList = null;
                List<CategoryEntity> category2Entities = getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", v.getCatId()));
                if (category2Entities != null)
                {
                    // 将category2Entities封装成List<Catalog2Vo>
                    // 先找3级子分类列表
                    catalog2VoList = category2Entities.stream().map(l2 -> {
                        List<CategoryEntity> category3Entities = getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", l2.getCatId()));
                        List<Catalog2Vo.Category3Vo> category3VoList = null;
                        if (category3Entities != null)
                        {
                            category3VoList = category3Entities.stream().map(l3 -> {
                                Catalog2Vo.Category3Vo catalog3Vo = new Catalog2Vo.Category3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                        }
                        Catalog2Vo catalog2Vo = new Catalog2Vo(l2.getParentCid().toString(), category3VoList, l2.getCatId().toString(), l2.getName());
                        return catalog2Vo;
                    }).collect(Collectors.toList());
                }
                return catalog2VoList;
            }));
        }
        return map;
    }
```

加本地锁synchronized：
```java

    /**
     * @description: p138 二级三级分类数据(使用redis)
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonUseRedisWithLocalLock() {
            ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
            // 先查redis缓存，没有再从mysql封装
            String catalogJson = stringRedisTemplate.opsForValue().get(CATALOG_JSON);
            // 查数据库
            if (catalogJson == null) {
                // 不能让所有线程都去访问数据库，压力太大，加锁  一个线程访问了写入缓存，后面其他线程都从缓存拿就行
                synchronized (this){
                    // 再查一遍缓存 （并发）
                    ValueOperations<String, String> ops1 = stringRedisTemplate.opsForValue();
                    // 先查redis缓存，没有再从mysql封装
                    String catalogJson1 = stringRedisTemplate.opsForValue().get(CATALOG_JSON);
                    if (catalogJson1!=null){
                        return JSON.parseObject(catalogJson1, new TypeReference<Map<String, List<Catalog2Vo>>>() {
                        });
                    }
                    Map<String, List<Catalog2Vo>> map = getCatalogJsonByDB();
                    // 写入redis (先转为json String, 方便跨语言和平台，直接写入java数据结构其他语言获取不方便)
                    ops.set(CATALOG_JSON, JSON.toJSONString(map));
                    return map;
                }
            } else {
                // 缓存里有直接返回
                log.info("缓存中有二级三级分类数据，直接返回");
                Map<String, List<Catalog2Vo>> map = JSON.parseObject(catalogJson, new TypeReference<Map<String, List<Catalog2Vo>>>() {
                });
                return map;
            }
    }
```

Controller: 
```java
@GetMapping("/index/catalog.json")
    public Map<String, List<Catalog2Vo>> getCatalogJson(){
        log.info("查询二级三级菜单数据");
        return categoryService.getCatalogJsonUseRedisWithLocalLock();
        //return categoryService.getCatalogJsonWithLock();
    }
```


测试：3个实例
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711451477435-5a92ee89-2405-47e1-af4a-9e81408159b2.png#averageHue=%23fdfcfb&clientId=u7c3c816c-fe7a-4&from=paste&height=51&id=u68d2cca0&originHeight=51&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5126&status=done&style=none&taskId=ud6b6b3af-e2d0-43c3-8587-2171acb315a&title=&width=800)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711451820100-53474101-3fb2-413c-89ef-68ad47343407.png#averageHue=%23c9c9c8&clientId=u7c3c816c-fe7a-4&from=paste&height=913&id=ufe13ec68&originHeight=913&originWidth=968&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59140&status=done&style=none&taskId=u6d1008a7-44b8-4df4-9b81-8ee14a2d3e1&title=&width=968)


给100并发循环1次：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711451579878-5eef224b-04dd-4ce8-967a-4833f3d0e1c5.png#averageHue=%233f4346&clientId=u7c3c816c-fe7a-4&from=paste&height=308&id=u1c13bdf2&originHeight=308&originWidth=856&originalType=binary&ratio=1&rotation=0&showTitle=false&size=28096&status=done&style=none&taskId=u0816a1fb-6e39-4ffb-98b4-be622f3f5fe&title=&width=856)
请求打到网关：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711451608657-4430e599-a401-4e65-a8ba-7be2891dde11.png#averageHue=%233e4346&clientId=u7c3c816c-fe7a-4&from=paste&height=304&id=u3860d62d&originHeight=304&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31081&status=done&style=none&taskId=u8182d059-5307-492c-a38f-76a652ff59a&title=&width=957)
网关配置负载均衡：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711451655087-9f0f1c88-1ae1-4a70-95de-8e5c7e3bbf1a.png#averageHue=%236d6649&clientId=u7c3c816c-fe7a-4&from=paste&height=236&id=u63de4276&originHeight=236&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48523&status=done&style=none&taskId=u0bfc8c94-ecc4-4473-95ef-9f32cd77a05&title=&width=882)

实例1（ip 127.0.0.1）：查询1次数据库
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711511662984-e4c526cb-e289-47db-99da-20f76ffbf9e2.png#averageHue=%2386885d&clientId=u9c386534-e867-4&from=paste&height=132&id=u8d03c6be&originHeight=132&originWidth=1001&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39438&status=done&style=none&taskId=u33dfd054-67c5-4b97-be76-2839534b984&title=&width=1001)
实例3(ip 192.168.30.130)：查询1次数据库
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711511579336-cdc6a146-15d5-4fb5-a65c-a65ed03e63b3.png#averageHue=%232f2925&clientId=u9c386534-e867-4&from=paste&height=32&id=u6d7963e9&originHeight=32&originWidth=918&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8555&status=done&style=none&taskId=u5bd8808c-1e4d-488a-b917-55ee3ef2510&title=&width=918)
实例2(ip 192.168.30.128)：查询1次数据库
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711511604922-59930894-2b1c-4a4d-b88f-f5beaee69aca.png#averageHue=%232c2724&clientId=u9c386534-e867-4&from=paste&height=42&id=u6c27ace7&originHeight=42&originWidth=928&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9720&status=done&style=none&taskId=ub4a169f3-818d-47ac-abfe-d21c7824b8d&title=&width=928)
总共查了3次数据库，压测报告：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711512086316-11db8d3c-c990-4edf-8182-3987f0207f83.png#averageHue=%233f4245&clientId=u069e9661-d171-4&from=paste&height=79&id=u3b68f9f6&originHeight=79&originWidth=1281&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9299&status=done&style=none&taskId=u85013a31-dc9d-40b8-89f2-3c345961e22&title=&width=1281)
# 3.分布式锁
基本原理：**所有的服务都去共同的地方占锁（而不是本地的每个实例上），例如redis里，比如有LOCK这个key了，说明其他线程已经占了这把锁，别的线程就不能再占了。**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711453715325-fc6f0070-ef71-4990-8883-30bae73143cd.png#averageHue=%23e6dddc&clientId=uc7373d99-4777-4&from=paste&height=331&id=ued64f20b&originHeight=331&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=55050&status=done&style=none&taskId=u891f038b-e27a-4647-8c17-6e6df7ac1b1&title=&width=582)

测试 set nx命令：
192.168.30.128打开两个会话框：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711456073975-56546cb6-2d80-4b90-a4ce-184eb25e11a7.png#averageHue=%23262423&clientId=u9c386534-e867-4&from=paste&height=199&id=u3bedaa7e&originHeight=199&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15388&status=done&style=none&taskId=uc913fa3c-bb6a-4239-bb7f-96e25292789&title=&width=654)
xshell 查看->撰写->撰写栏调出如下输入框：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711456290687-0aac5692-f57b-4f28-8004-24bc4f675823.png#averageHue=%23938d8c&clientId=u9c386534-e867-4&from=paste&height=182&id=u39b10d1f&originHeight=182&originWidth=385&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6711&status=done&style=none&taskId=u600722ad-b98a-4d4b-98d0-9d640a5c866&title=&width=385)
勾选全部会话，就能将命令发给所有会话：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711456033769-dbeea2a4-d93b-408d-a204-4a7d481b398f.png#averageHue=%23d2cec7&clientId=u9c386534-e867-4&from=paste&height=440&id=ub2a05963&originHeight=440&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&size=229818&status=done&style=none&taskId=uaecd7e74-fead-4bbb-b4dd-c4c6570ab3b&title=&width=745)
回车发送。
执行占锁命令：
```java
set LOCK 1 NX  #key为LOCK，值为1，可以随便起；NX不存在才设置（多个同时执行只有一个能成功）
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711456377939-9f7dd4c5-45c7-45bf-ae01-b138469dbe17.png#averageHue=%23b6b1b1&clientId=u9c386534-e867-4&from=paste&height=85&id=u1abf039b&originHeight=85&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2270&status=done&style=none&taskId=u283706ed-3214-4a5c-a954-37707e17f02&title=&width=339)

只有1个能成功：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711456489352-4c19b4a5-2b19-4d38-853d-6499b667d71f.png#averageHue=%23332b28&clientId=u9c386534-e867-4&from=paste&height=177&id=u3c896739&originHeight=177&originWidth=408&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15657&status=done&style=none&taskId=u263d39c2-5678-47a4-bd60-33398a8e032&title=&width=408)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711456510259-d7a4262b-002d-452e-a811-18df244fb631.png#averageHue=%2329211d&clientId=u9c386534-e867-4&from=paste&height=226&id=u576ce7c4&originHeight=226&originWidth=439&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23559&status=done&style=none&taskId=uadecb503-ef8a-4466-b43c-111a556c201&title=&width=439)



脚本删锁：
[https://redis.io/commands/set/](https://redis.io/commands/set/)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711463651404-9ed82643-5fd7-4063-991f-864863d24b4f.png#averageHue=%23d0d1d5&clientId=u9c386534-e867-4&from=paste&height=910&id=u059fc8c4&originHeight=910&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109025&status=done&style=none&taskId=u84a39d08-dabb-40b7-b2a1-726bdbae727&title=&width=762)
**分布式锁，注意两点：占锁和删锁都是原子操作**

1. 占分布式锁
-  去redis占坑（创建一个key为LOCK的键值对），百万并发进来，都去占坑，但只有一个能set成功  set key value NX命令。
- 占锁和设置过期时间必须同时, 且value是一个uuid（作为当前线程的唯一标识，删锁时核对防止删除别人的锁）
2.  释放锁 ：
-  考虑业务代码太长时可能当前线程还没执行完锁就过期了，其他线程获取锁，等自己执行完却删了别的线程的锁  ->  解决： 占锁时设置uuid，删锁时核对uuid确认是自己的锁
-   考虑从redis获取再传输回来有时延，如下情况： 过期时间10s， 当前时刻9.8s，判断是自己的锁 ，传回来花了0.5s，导致传回来判断是自己的锁，但过期把锁删了，所以还是删的别的线程的锁  ->  解决： 判断和删锁也要同时->运行脚本删锁 参考：[https://redis.io/commands/set/](https://redis.io/commands/set/)
```java
/**
     * @description: p138 二级三级分类数据(使用redis) 加分布式锁
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonWithLock() {
        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
        // 先查redis缓存，没有再从mysql封装
        String catalogJson = stringRedisTemplate.opsForValue().get(CATALOG_JSON);
        // 查数据库
        Map<String, List<Catalog2Vo>> map = null;
        if (catalogJson == null) { // 缓存不命中查数据库
            map = getCatalogJsonFromDBWithDistributeLock();
            // 写入redis (先转为json String, 方便跨语言和平台，直接写入java数据结构其他语言获取不方便)
            ops.set(CATALOG_JSON, JSON.toJSONString(map));
        } else {
            // 缓存里有直接返回
            log.info("缓存中有二级三级分类数据，直接返回");
            map = JSON.parseObject(catalogJson, new TypeReference<Map<String, List<Catalog2Vo>>>() {
            });
        }
        return map;
    }
    /**
     * @description: 从数据库查询二级三级分类数据 加分布式锁
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    public Map<String, List<Catalog2Vo>> getCatalogJsonFromDBWithDistributeLock() {
        //log.info("缓存中没有二级三级分类数据，开始查询数据库");
        // 占分布式锁，去redis占坑（创建一个key为LOCK的键值对），百万并发进来，都去占坑，但只有一个能set成功  set key value NX命令
        // 占锁和设置过期时间必须同时, 且value是一个uuid（作为当前线程的唯一标识，删锁时核对防止删除别人的锁）
        String uuid = UUID.randomUUID().toString();
        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(LOCK, uuid, 5, TimeUnit.MINUTES); // 设置过期时间防止异常或者断电导致死锁，过期时间设长一点，防止业务执行太久
        if (lock) { // 占锁成功
            log.info("获取分布式锁成功");
            String catalogJson=stringRedisTemplate.opsForValue().get(CATALOG_JSON);
            // 拿到锁先判断缓存里有没有，有直接释放锁返回
            if(catalogJson!=null){
                log.info("缓存中有二级三级分类数据，直接返回");
                releaseLock(uuid);
                return JSON.parseObject(catalogJson,new TypeReference<Map<String, List<Catalog2Vo>>>(){});
            }
            Map<String, List<Catalog2Vo>> map = null;
            try {
                map = getCatalogJsonByDB();
                stringRedisTemplate.opsForValue().set(CATALOG_JSON, JSON.toJSONString(map));
            } finally { // 无论业务执行成功或失败，都要解锁
                releaseLock(uuid);
                return map;
            }
        } else {  // 占锁失败，重试
            log.info("获取分布式锁失败，等待重试");
            try {
                Thread.sleep(200); // 等待200ms，一直调会OOM
            } catch (Exception e) {
            }
            return getCatalogJsonFromDBWithDistributeLock();
        }
    }
    /**
     * @description: 释放锁
     * @param:
     * @param uuid
     * @return: void
     **/
    public void releaseLock(String uuid){
        // 无论业务执行成功或失败，都要解锁
        // 释放锁 ：
        // 1.考虑业务代码太长时可能当前线程还没执行完锁就过期了，其他线程获取锁，等自己执行完却删了别的线程的锁  ->
        // 解决： 占锁时设置uuid，删锁时核对uuid确认是自己的锁
        // 2.考虑从redis获取再传输回来有时延，如下情况： 过期时间10s， 当前时刻9.8s，判断是自己的锁 ，传回来花了0.5s，导致传回来判断是自己的锁，但过期把锁删了，所以还是删的别的线程的锁
        // 解决： 判断和删锁也要同时->运行脚本删锁 参考：https://redis.io/commands/set/
        String script = "if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end";
        // DefaultRedisScript<T> 泛型T为返回值泛型，删成功为1，失败为0
        stringRedisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList(LOCK), uuid);
    }
```
Controller:
```java
@GetMapping("/index/catalog.json")
    public Map<String, List<Catalog2Vo>> getCatalogJson(){
        log.info("查询二级三级菜单数据");
        return categoryService.getCatalogJsonWithLock();
    }
```

总共只查1次数据库
192.168.30.128：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711508291099-64d23611-1aba-4673-a631-18e4054fc1f1.png#averageHue=%232b2623&clientId=u9c386534-e867-4&from=paste&height=41&id=u1bddfb83&originHeight=41&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9148&status=done&style=none&taskId=u2a2cdc22-956e-4568-bcd9-bb004b81423&title=&width=917)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711508415531-89d125c3-c1b3-4414-8359-07010792369e.png#averageHue=%23342b27&clientId=u9c386534-e867-4&from=paste&height=400&id=u629c6440&originHeight=400&originWidth=1104&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137287&status=done&style=none&taskId=u8b95cf8c-f237-40ff-a265-404e1a3697a&title=&width=1104)

192.168.30.130：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711508315304-609d3caa-8441-4deb-834a-5b665e822889.png#averageHue=%232b2724&clientId=u9c386534-e867-4&from=paste&height=37&id=u6f48cf17&originHeight=37&originWidth=607&originalType=binary&ratio=1&rotation=0&showTitle=false&size=5312&status=done&style=none&taskId=u7534c51c-0d8d-4b10-94a6-c52baba4bf6&title=&width=607)

127.0.0.1：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711508336676-b2127951-c933-499e-a876-dedb0a9fe1b8.png#averageHue=%2387734f&clientId=u9c386534-e867-4&from=paste&height=171&id=u9a864eff&originHeight=171&originWidth=1089&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54376&status=done&style=none&taskId=u002bbe52-60d2-4742-ae6d-09fb15cb302&title=&width=1089)
压测报告：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711512398890-a3f8ff4d-67d6-4f27-9fe1-f4404608afde.png#averageHue=%233f4244&clientId=u0643755e-f135-4&from=paste&height=85&id=u63122b8d&originHeight=85&originWidth=1286&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9849&status=done&style=none&taskId=u81a6a6f0-428e-4499-998e-fa35ef0404e&title=&width=1286)
# 4.Redission分布式锁框架
**3中加分布式锁的方法不推荐，有专门的框架Redission**
参考： [https://redis.io/docs/manual/patterns/distributed-locks/](https://redis.io/docs/manual/patterns/distributed-locks/)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711513243896-d30e3b45-cca1-4366-958b-808be24cd772.png#averageHue=%23fefefe&clientId=u596a6ae5-e4ef-4&from=paste&height=1061&id=u579df7eb&originHeight=1061&originWidth=762&originalType=binary&ratio=1&rotation=0&showTitle=false&size=164517&status=done&style=none&taskId=ub7e0c74c-9aae-423c-9945-c27dc9b159b&title=&width=762)

分布式锁 redission: [https://github.com/redisson/redisson/wiki](https://github.com/redisson/redisson/wiki)
支持中文：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711513339591-17f6878b-d693-47d8-8316-aeb265fbfbc0.png#averageHue=%23fefefe&clientId=u596a6ae5-e4ef-4&from=paste&height=781&id=ud180845e&originHeight=781&originWidth=1241&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69438&status=done&style=none&taskId=u51c95b49-56b2-4440-923c-a8874169ca1&title=&width=1241)

## 4.1 Redission介绍
Redisson是一个**在Redis的基础上**实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。其中包括(BitSet, Set, Multimap, SortedSet, Map, List, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, AtomicLong, CountDownLatch, Publish / Subscribe, Bloom filter, Remote service, Spring cache, Executor service, Live Object service, Scheduler service) Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。
## 4.2 整合Redission
### 4.2.1引入依赖
[https://mvnrepository.com/artifact/org.redisson/redisson](https://mvnrepository.com/artifact/org.redisson/redisson)
```java
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.27.2</version>
</dependency>
```
### 4.2.2 配置
[https://github.com/redisson/redisson/wiki/2.-Configuration](https://github.com/redisson/redisson/wiki/2.-Configuration)
中文：[配置方法](https://github.com/redisson/redisson/wiki/2.-%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95)
以下使用programmatic-configuration
区分单节点和集群模式参考： [https://github.com/redisson/redisson/wiki/2.-Configuration#21-programmatic-configuration](https://github.com/redisson/redisson/wiki/2.-Configuration#21-programmatic-configuration)
```java
package com.atguigu.product.config;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Bean;

import java.io.IOException;
/**
 * @Author qiang.long
 * @Date 2024/03/27
 * @Description Redisson配置
 **/

@Configuration
public class RedissonConfig {
    /**
     * @description: 往容器中注入RedissonClient对象（所有redisson的操作都要通过它）
     * @param:
     * @return: org.redisson.api.RedissonClient
     **/
    @Bean(destroyMethod="shutdown")
    public RedissonClient redisson() throws IOException {
        Config config = new Config();
        config.useSingleServer()  // 单节点模式
                .setAddress("redis://192.168.30.128:6379"). // redis地址和端口
                setPassword("181181@Lq");   // 密码
        // 创建实例
        return Redisson.create(config);
    }
}

```
单元测试：
```java
@Autowired
    private RedissonClient redissonClient;
@Test
    public void testRedisson(){
        System.out.println(redissonClient);
    }
```
## 4.3 使用分布式锁
参考：[https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers](https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers)
中文：[分布式锁和同步器](https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8)
### 4.3.1可重入锁（Reentrant Lock）
可重入锁允许同一个线程在持有锁的情况下多次获取该锁，而不会发生死锁。假设如下场景：A方法调用B方法，给A和B加同一把锁，那么等B执行完后释放锁，然后A再释放锁。若设计为不可重入，则会造成死锁现象。**因此，所有锁都应该设计为可重入锁，避免死锁。**
```java
A(){

    ... code
    B()   // A方法里调用B方法
}
```
基于Redis的Redisson分布式可重入锁[RLock](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RLock.html) Java对象实现了java.util.concurrent.locks.Lock接口。
**关键：**

1. redissonClient.getLock获取一把锁只要锁名字相同就是同一把锁，能锁住用它的所有线程
2. lock.lock()加锁，它会锁住从lock.lock()到lock.unlock()间的所有代码。若其他线程占有锁，会阻塞式等待。
3. lock.unlock()解锁，必须放到finally防止出现异常造成死锁

测试示例：
```java
@Autowired
    private RedissonClient redissonClient;

@GetMapping("/hello")
    public String getHello(){
        // 1. 获取一把锁，只要锁名字相同就是同一把锁，能锁住用它的所有线程
        RLock lock=redissonClient.getLock("my-lock");
        // 2.加锁
        lock.lock();  // 阻塞式等待
        try {
            log.info("线程{}获取到锁，执行业务",Thread.currentThread().getId());
            Thread.sleep(40000); // 睡40s
        }catch (Exception e){

        }finally{
            // 3. 解锁 放到finally防止出现异常造成死锁
            log.info("释放锁{}",Thread.currentThread().getId());
            lock.unlock();
            return "hello";
        }
    }
```

同时发两个hello请求，模拟两个线程：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711626524908-198de5a7-3a20-4ade-b381-fb9b131270bc.png#averageHue=%23fffaf5&clientId=ua368c1af-6f17-4&from=paste&height=157&id=u9d0ce8b2&originHeight=157&originWidth=540&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7534&status=done&style=none&taskId=ue06271db-1dbe-4a6f-82c8-17ceba61deb&title=&width=540)
97号线程执行完释放锁后98号线程才能获取锁：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711626583643-8786f012-7a15-470c-aa52-c319da2eae81.png#averageHue=%23846e4d&clientId=ua368c1af-6f17-4&from=paste&height=130&id=ue12927b3&originHeight=130&originWidth=1023&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33756&status=done&style=none&taskId=u203533f5-8805-4990-97f2-d360309720a&title=&width=1023)
redis里查看锁信息：值里有线程号信息，并且有过期时间TTL（单位s）
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711626553746-df02d085-088e-4c0a-94cd-087fdd276738.png#averageHue=%23f3f1f0&clientId=ua368c1af-6f17-4&from=paste&height=103&id=u395eb712&originHeight=103&originWidth=708&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9252&status=done&style=none&taskId=uaa07cc22-ea87-449a-92f3-01a9e5d619b&title=&width=708)
看门狗机制：

1. 锁的自动续期，如果业务超长，运行期间会给锁自动续期(默认过期时间30s，每过10s就自动续期)。不用担心业务时间长锁自动过期被删掉。
2. 若未指定过期时间，就是用30*1000【lockWatchdogTimeout看门狗的默认时间】。只要占锁成功，就会启动一个定时任务【重新给锁设置过期时间，新的过期时间就是看门狗的默认时间】，1/3*看门狗时间 (10s)一续期。
3. 加锁的业务只要运行完成，就不会给锁续期，即使不手动解锁，锁也默认在30s后自动删除。（模拟：上面的代码（分布式运行），在运行sleep期间把服务停掉）



指定过期时间：
```java
lock.lock(10, TimeUnit.SECONDS);  // 指定过期时间
```
```java
 @GetMapping("/hello1")
    public String getHelloSetTTL(){
        // 1. 获取一把锁，只要锁名字相同就是同一把锁，能锁住用它的所有线程
        RLock lock=redissonClient.getLock("my-lock");
        // 2.加锁
        lock.lock(10, TimeUnit.SECONDS);  // 阻塞式等待 ,指定过期时间
        try {
            log.info("线程{}获取到锁",Thread.currentThread().getId());
            Thread.sleep(30000);
        }catch (Exception e){

        }finally{
            // 3. 解锁 放到finally防止出现异常造成死锁
            log.info("释放锁{}",Thread.currentThread().getId());
            lock.unlock();
            return "hello";
        }
    }
```
注意：**当指定的过期时间小于业务运行时间（10s<30s），锁会被删掉，不会自动续期。**
**手动删锁出现异常：因为锁不是自己的了。**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711628066057-bef0a915-037f-4c2b-b4df-1ff3346223ee.png#averageHue=%232f2e2d&clientId=ua368c1af-6f17-4&from=paste&height=82&id=u979afe9b&originHeight=82&originWidth=2230&originalType=binary&ratio=1&rotation=0&showTitle=false&size=33516&status=done&style=none&taskId=ubb04c5b3-c333-438f-9278-0b1408eeb35&title=&width=2230)

**建议：**
**用指定过期时间，只要把过期时间设大点就行，比如30s。**

**tryLock: 不会一直等待，可以设置一个最长等待时间，过了这个时间还拿不到就返回false。**
```java
RLock lock=redissonClient.getLock("my-lock");
// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁
boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);
if (res) {
   try {
     ...
   } finally {
       lock.unlock();
   }
}
```

### 4.3.2读写锁（ReadWriteLock）
基于Redis的Redisson分布式可重入读写锁[RReadWriteLock](http://static.javadoc.io/org.redisson/redisson/3.4.3/org/redisson/api/RReadWriteLock.html) Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。其中读锁和写锁都继承了[RLock](https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8#81-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81reentrant-lock)接口。分布式可重入读写锁允许同时有多个读锁和一个写锁处于加锁状态。
读写锁设计的目的：**保证一定能读到最新数据，修改期间，写锁是一个排他锁（互斥锁），读锁是一个共享锁。写锁没释放读锁就必须等待。**
**4种模式：**

1. 读+读： 相当于无锁，并发读，只会在redis中记录好所有当前的读锁，它们都会加锁成功。
2. 写+读：读锁必须等待写锁释放
3. 写+写：阻塞方式
4. 读+写：有读锁，写也需要等待。

总结：**只要有写锁存在，都必须等待。**

```java
// 2.读写锁
// 写锁
@GetMapping("/write")
public String writeValue(){
    RReadWriteLock rReadWriteLock=redissonClient.getReadWriteLock("rw-lock");
    RLock rLock=rReadWriteLock.writeLock();  // 拿到写锁
    rLock.lock(); // 加锁
    String s=null;
    try {
        s=UUID.randomUUID().toString();
        log.info("写锁加锁成功{}",Thread.currentThread().getId());
        Thread.sleep(30000);
        stringRedisTemplate.opsForValue().set("writeValue", s);
    } catch (InterruptedException e)
    {
        throw new RuntimeException(e);
    } finally {
        log.info("写锁释放{}",Thread.currentThread().getId());
        rLock.unlock();
    }
    return s;
}

// 读锁
@GetMapping("/read")
public String readValue(){
    RReadWriteLock rReadWriteLock=redissonClient.getReadWriteLock("rw-lock");
    RLock rLock=rReadWriteLock.readLock();  // 拿到读锁
    rLock.lock(); // 加锁
    String s=null;
    try {
        log.info("读锁加锁成功{}",Thread.currentThread().getId());
        Thread.sleep(30000);
        s=stringRedisTemplate.opsForValue().get("writeValue");
    } catch (InterruptedException e)
    {
        throw new RuntimeException(e);
    } finally {
        log.info("读锁释放{}",Thread.currentThread().getId());
        rLock.unlock();
    }
    return s;
}
```

读+读：
先发一个写请求，后发3个读请求，可以看到写锁释放后同时获取到读锁，相当于无锁。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632234513-1ed329e6-a24e-4c50-a278-1dc26db79941.png#averageHue=%23ecede6&clientId=ub38272a5-976d-4&from=paste&height=152&id=u6adfb664&originHeight=152&originWidth=995&originalType=binary&ratio=1&rotation=0&showTitle=false&size=19987&status=done&style=none&taskId=u9d7f1721-bf8b-4106-8b10-be9a1e59436&title=&width=995)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632308822-707ad503-1e2c-4909-9485-fe3dbd9b333e.png#averageHue=%2331302f&clientId=ub38272a5-976d-4&from=paste&height=188&id=ud2768203&originHeight=188&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59548&status=done&style=none&taskId=u3382aa0c-e62a-43e6-91ab-426c2f19538&title=&width=944)

写+读：先发一个write请求，后发一个read请求。读必须等写完才有返回。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711631424360-e1533e2c-3a7d-45f3-b089-e1553de69c1b.png#averageHue=%23e7debe&clientId=ub38272a5-976d-4&from=paste&height=130&id=ubcb805c6&originHeight=130&originWidth=475&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10212&status=done&style=none&taskId=u46957274-5cfd-4080-a98c-4b6478ffc1d&title=&width=475)
值会显示锁的模式（write/read）
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711631231798-f645a8ed-8d59-40c5-9a0f-2568bc4dbbb8.png#averageHue=%23f7f5f4&clientId=ub38272a5-976d-4&from=paste&height=98&id=u2c33467a&originHeight=98&originWidth=705&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8940&status=done&style=none&taskId=u46a23124-b1ae-4491-8224-e316a522ddf&title=&width=705)

读+写：读完后才能写
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632088094-91dd7bab-95f5-4c9a-95f1-92ea4144b23b.png#averageHue=%23302f2e&clientId=ub38272a5-976d-4&from=paste&height=79&id=ub58e048f&originHeight=79&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23201&status=done&style=none&taskId=u74922730-cf3b-47db-b308-7d9831abdc5&title=&width=956)
### 4.3.3信号量
基于Redis的Redisson的分布式信号量（[Semaphore](http://static.javadoc.io/org.redisson/redisson/3.10.0/org/redisson/api/RSemaphore.html)）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。
信号量：**用于限制同时执行某个操作的线程数量**。Semaphore 会维护一定数量的许可证（permits），线程在执行前必须先获取许可证，执行完后释放许可证。
模拟：车库仅有3个停车位，都停满了其他车想停就得等有空位。
```java
// 信号量模拟
    /**
     * @description: 信号量模拟（信号量即设置同时访问特定资源的线程数）：总共3个车位，没有空余其车辆就必须等待
     * @param:
     * @return: java.lang.String
     **/
    // 停车：占车位（模拟占用信号）
    @GetMapping("/park")
    public String park() throws InterruptedException {
        // 获取信号量
        RSemaphore rSemaphore=redissonClient.getSemaphore("park");
        rSemaphore.acquire(); // 获取一个信号（车位）
        return "ok";
    }
    // 把车开走：模拟释放信号
    @GetMapping("/go")
    public String go() throws InterruptedException {
        RSemaphore rSemaphore=redissonClient.getSemaphore("park");
        rSemaphore.release(); // 释放一个信号（车位）
        return "ok";
    }
```

先在redis中预置信号量初始值3：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632716534-eda21e7e-3ef2-4f66-80f6-41eddbe401d3.png#averageHue=%23caa66d&clientId=u8a672157-015e-4&from=paste&height=108&id=u1872472e&originHeight=108&originWidth=648&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8212&status=done&style=none&taskId=ucd3495f4-1e7d-47c6-9eaa-a1002e6f41f&title=&width=648)

发送1个park请求后redis里值变为2：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632792768-17fce5bd-87fd-4804-9ffb-da8f1fc3aedc.png#averageHue=%23dab786&clientId=u8a672157-015e-4&from=paste&height=76&id=u1e57a3fd&originHeight=76&originWidth=325&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3717&status=done&style=none&taskId=u583c48ed-3a28-430f-90c5-7c315a67d81&title=&width=325)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632768782-36f21f6a-ae6c-438c-9054-de3821e4aa8e.png#averageHue=%23efefee&clientId=u8a672157-015e-4&from=paste&height=85&id=u0e1a99d7&originHeight=85&originWidth=347&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3509&status=done&style=none&taskId=u1b837d76-912d-42fb-aeab-da873f0588e&title=&width=347)
再发送一个go请求又变为3：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711632829804-505b2f15-469f-4e60-829e-2afaa09728cb.png#averageHue=%23c29a5e&clientId=u8a672157-015e-4&from=paste&height=76&id=u7a77022a&originHeight=76&originWidth=318&originalType=binary&ratio=1&rotation=0&showTitle=false&size=2873&status=done&style=none&taskId=u378c502a-aa77-4a3b-a1fb-7dd9ae42255&title=&width=318)
连续发4个park请求，最后一个park请求必须等待，因为信号量为0了。
### 4.3.4 闭锁（CountDownLatch）
```java
 // 4.闭锁模拟
    /**
     * 锁门：必须等5个班的人都走了
     **/
    @GetMapping("/lockDoor")
    public String lockDoor() throws InterruptedException {
        // 获取闭锁
        RCountDownLatch rCountDownLatch=redissonClient.getCountDownLatch("door-lock");
        log.info("获取到闭锁");
        rCountDownLatch.trySetCount(5); // 设置等待数（即5个线程都执行完完了）
        rCountDownLatch.await();// 等待闭锁都完成
        log.info("放假了");
        return "放假了";
    }

    @GetMapping("/gogogo/{id}")
    public String gogogo(@PathVariable("id") Long id) {
        RCountDownLatch rCountDownLatch=redissonClient.getCountDownLatch("door-lock");
        rCountDownLatch.countDown(); // 计数减1
        log.info("{}班的人都走了",id);
        return id+"班的人都走了";
    }
```

先发lockDoor请求，等待，再发gogogo请求，必须等5个gogogo请求执行完成lockDoor才会执行返回“放假了”
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711634226502-b3a910ee-5d57-4fc9-99e8-86f8f6422674.png#averageHue=%23ddbb86&clientId=ua69489e7-ac85-4&from=paste&height=182&id=ucf09dc35&originHeight=182&originWidth=990&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13186&status=done&style=none&taskId=uc9583615-3060-41ed-ace0-5d85a000579&title=&width=990)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711634180437-c250a8f6-52aa-439e-b68e-b305ae37965d.png#averageHue=%23f3f3f2&clientId=ua69489e7-ac85-4&from=paste&height=108&id=uecdb7813&originHeight=108&originWidth=563&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6640&status=done&style=none&taskId=u3839cf32-295d-43f2-9b1d-6b0ac681a47&title=&width=563)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711634388440-883aaf94-7b7c-4a3d-a530-fc8271ec3463.png#averageHue=%2331302f&clientId=ua69489e7-ac85-4&from=paste&height=156&id=u63e84543&originHeight=156&originWidth=930&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52034&status=done&style=none&taskId=u06365d41-d466-4265-aa92-5cc8cf57e4b&title=&width=930)
## 4.4 分布式锁缓存一致性问题
问题：何如保证缓存中的数据和数据库中的保持一致？
方案：

- **双写模式**： 只要数据库更新了，就同时更新涉及到的缓存。
- **失效模式**：写数据库时删除相关缓存，下次查询时由于缓存中没有会直接查数据库并更新缓存。

两种方案的问题：


![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711634622139-169802f8-820f-42df-964c-e1edb71f0112.png#averageHue=%23f4f2f1&clientId=u64f2a5c7-2d6f-4&from=paste&height=586&id=ue7739c9b&originHeight=586&originWidth=1049&originalType=binary&ratio=1&rotation=0&showTitle=false&size=128475&status=done&style=none&taskId=u71ec8c9d-2d52-4048-98ff-83bd89db66b&title=&width=1049)
双写模式问题模拟：
线程1进来将数据库里的数据改为1，结果还没来得及写入缓存时间片就用完了，切换到线程2，它将数据库改为2并写入缓存；接着时间片切换到线程1，此时线程1将缓存里的数据改为1。这样缓存里就出现了脏数据（最后数据库中数据是2）。
解决：
法一：加锁，将写数据和写缓存做成一个原子操作。
法二：若对数据实时性要求不是很高，可给缓存加一个过期时间，过期之后就会再从数据库里查最新的数据并写入缓存，不一致只是暂时的。





![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711634859591-a9666c85-20d6-483e-903b-6916a1871085.png#averageHue=%23f1eeeb&clientId=u64f2a5c7-2d6f-4&from=paste&height=559&id=u674fdcde&originHeight=559&originWidth=1045&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133626&status=done&style=none&taskId=u0306dba9-5ab3-44d6-8eb5-98782a0bc01&title=&width=1045)
失效模式问题模拟：
线程1将数据库改为1，删缓存；线程3读缓存，由于缓存为空去读数据库，读到的是1，这时线程3时间片用完了；线程2将数据库中同一份数据改为2，并删缓存（但缓存已被删，且线程3没有写入新缓存，删了个寂寞）；最后切换到线程3，它将1写入缓存。因此最后数据库是2，但缓存是1，同样是脏数据。
解决：加锁活设置过期时间（短暂不一致）

忽略下面的解释：感觉不好
线程1（负载均衡到1号机器）将数据库改为1并删缓存；线程2（负载均衡到2号机器）将数据库改为2期间，线程3（负载均衡到3号机器）执行读请求，发现缓存中没有数据，于是去读数据库，问题来了：机器2运行速度较慢，数据2写入数据库还未完成，因此线程3读到的是线程1修改后的数据，更巧的是等线程3读完数据后线程2将缓存也删了，因此线程3更新缓存写入的数据是1，可数据库里最新数据是2，也是脏数据。


上面两个问题都可以加锁解决，但会让系统更加笨重。
解决方案：

1. **仅缓存读多写少或只读的数据**，对于写入非常频繁的直接查数据库，放入缓存又加锁反而笨重，效率慢。
2. 采用失效模式或双写模式
3. **所有缓存都设置过期时间，并且采用分布式读写锁**

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711635738559-d0349534-818a-471c-a9a9-f9b6a672e67e.png#averageHue=%23f2ecea&clientId=u248336f9-3b68-4&from=paste&height=473&id=u35041a90&originHeight=473&originWidth=1057&originalType=binary&ratio=1&rotation=0&showTitle=false&size=228539&status=done&style=none&taskId=ud6c445f2-0ce7-4d13-b8e3-c55f0e6096f&title=&width=1057)



业务代码改造:
```java
    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Autowired
    private RedissonClient redissonClient;
/**
     * @description: p138 二级三级分类数据(使用redis) 加分布式锁
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonWithLock() {
        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();
        // 先查redis缓存，没有再从mysql封装
        String catalogJson = stringRedisTemplate.opsForValue().get(CATALOG_JSON);
        // 查数据库
        Map<String, List<Catalog2Vo>> map = null;
        if (catalogJson == null) { // 缓存不命中查数据库
            //map = getCatalogJsonFromDBWithDistributeLock();
            map=getCatalogJsonFromDBWithRedisson();
            // 写入redis (先转为json String, 方便跨语言和平台，直接写入java数据结构其他语言获取不方便)
            ops.set(CATALOG_JSON, JSON.toJSONString(map));
        } else {
            // 缓存里有直接返回
            log.info("缓存中有二级三级分类数据，直接返回");
            map = JSON.parseObject(catalogJson, new TypeReference<Map<String, List<Catalog2Vo>>>() {
            });
        }
        return map;
    }

 /**
     * @description: 使用Redisson加分布式锁
     * @param:
     * @return: List<Catalog2Vo>>
     **/
    public Map<String, List<Catalog2Vo>> getCatalogJsonFromDBWithRedisson() {
        // 获取一把锁
        RLock lock=redissonClient.getLock("CatalogJson-Lock");
        lock.lock(); // 加锁 阻塞式等待  锁住lock()到unlock()间的所有代码
        log.info("获取分布式锁成功");
        String catalogJson=stringRedisTemplate.opsForValue().get(CATALOG_JSON);
        // 拿到锁先判断缓存里有没有，有直接释放锁返回
        if(catalogJson!=null){
            log.info("缓存中有二级三级分类数据，直接返回");
            lock.unlock();  // 释放锁
            return JSON.parseObject(catalogJson,new TypeReference<Map<String, List<Catalog2Vo>>>(){});
        }
        Map<String, List<Catalog2Vo>> map = null;
        try {
            map = getCatalogJsonByDB();
            stringRedisTemplate.opsForValue().set(CATALOG_JSON, JSON.toJSONString(map));
        } finally { // 无论业务执行成功或失败，都要解锁
            lock.unlock();  // 释放锁
            return map;
        }

    }

```

# 5.SpringCahe
## 5.1概述
官方文档：[https://docs.spring.io/spring-framework/reference/integration/cache.html](https://docs.spring.io/spring-framework/reference/integration/cache.html)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711704037703-d95278b1-2d1e-4feb-a1b6-bf4188fd9979.png#averageHue=%23252b31&clientId=uce96c6c3-0642-4&from=paste&height=732&id=ufcb965d6&originHeight=732&originWidth=1005&originalType=binary&ratio=1&rotation=0&showTitle=false&size=120494&status=done&style=none&taskId=u7bc92e73-b5d6-4190-b847-ab6b6c885d6&title=&width=1005)
[https://docs.spring.io/spring-framework/reference/index.html](https://docs.spring.io/spring-framework/reference/index.html)
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711703944491-3f9865c6-d0dc-450c-aca7-aa96679ec051.png#averageHue=%23252a30&clientId=uce96c6c3-0642-4&from=paste&height=705&id=uae42b310&originHeight=705&originWidth=1083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=121638&status=done&style=none&taskId=u9c09d19b-aeaf-4905-af9a-8b9f04f1b44&title=&width=1083)



1.  Spring 从 3.1 开始定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager 接口来统一不同的缓存技术； 并支持使用 JCache（JSR-107）注解简化我们开发；  
2.  Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache 接 口 下 Spring 提 供 了 各 种 xxxCache 的 实 现 ； 如 RedisCache ， EhCacheCache , ConcurrentMapCache 等；  
3.  每次调用需要缓存功能的方法时，Spring 会检查检查指定参数的指定的目标方法是否已 经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓 存结果后返回给用户。下次调用直接从缓存中获取。  
4.  使用 Spring 缓存抽象时需要关注以下两点：
   - 确定方法需要被缓存以及他们的缓存策略 
   - 从缓存中读取之前缓存存储的数据  

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711700962558-85311c50-98bb-40b5-bb55-fe94f4c2d8b5.png#averageHue=%2397be7b&clientId=uce96c6c3-0642-4&from=paste&height=499&id=uadcb967e&originHeight=499&originWidth=831&originalType=binary&ratio=1&rotation=0&showTitle=false&size=233711&status=done&style=none&taskId=uc17200f0-1fae-4eea-8072-843f939b442&title=&width=831)

## 5.2 注解
官方文档：[https://docs.spring.io/spring-framework/reference/integration/cache/jsr-107.html](https://docs.spring.io/spring-framework/reference/integration/cache/jsr-107.html)

| @EnableCaching | 开启缓存功能 |
| --- | --- |
| @Cacheable | 主要针对方法配置，将方法返回结果保存到缓存 |
| @CacheEvict | 删除缓存 |
| @CachePut | 不影响方法执行更新缓存 |
| @Caching | 组合多种缓存操作 |
| @CacheConfig | 在类级别共享相同的缓存配置 |


| Cache | 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 |
| --- | --- |
| CacheManager | 缓存管理器，管理各种缓存（Cache）组件 |
| keyGenerator | 缓存数据时key生成策略 |
| serialize | 缓存数据时value序列化策略 |

## 5.2 引入依赖
```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!--想要用redis作为缓存，必须引这个-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```
## 5.3配置
### 5.3.1自动配置

1. CacheAutoConfiguration会导入RedisCacheConfiguration，自动配好了缓存管理器RedisCacheManager。

在CacheAutoConfiguration中：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711701581264-c3bf43c2-d6e5-4fa9-9758-89ecede53e0d.png#averageHue=%232f2d2b&clientId=uce96c6c3-0642-4&from=paste&height=571&id=uf04e2257&originHeight=571&originWidth=710&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76383&status=done&style=none&taskId=ub7be5e50-785d-4a58-845d-81803dba05e&title=&width=710)
yml中缓存能配的属性在CacheProperties里：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711701636270-4410e675-27da-4178-9b50-e31eb04451f3.png#averageHue=%232e2d2b&clientId=uce96c6c3-0642-4&from=paste&height=465&id=u7d46bea4&originHeight=465&originWidth=544&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46181&status=done&style=none&taskId=u49d87f9c-a433-4f68-ad51-4e86d8a86be&title=&width=544)
导入缓存配置类：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711701766318-07ace10e-51ab-4a6f-b8d2-566c4a9d25e2.png#averageHue=%232e2c2b&clientId=uce96c6c3-0642-4&from=paste&height=398&id=u286ff2e6&originHeight=398&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40399&status=done&style=none&taskId=u3ee43cf9-3806-4cdc-bf3b-652a28842ab&title=&width=675)
redis相关:
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711701812293-735a11d1-19d7-4bf5-bfab-521ae69027ae.png#averageHue=%23332e2c&clientId=uce96c6c3-0642-4&from=paste&height=325&id=u594ef6c2&originHeight=325&originWidth=721&originalType=binary&ratio=1&rotation=0&showTitle=false&size=73824&status=done&style=none&taskId=ue68c7693-8016-45a8-9ad4-bea4f1be093&title=&width=721)
### 5.3.2手动配置
application.yml:
```yaml
spring:
  # Spring Cache
  cache:
    type: redis  #缓存的类型
    redis:
      time-to-live: 60000   #过期时间，单位ms  即1min
      cache-null-values: true  #是否缓存空值，防止缓存穿透
```
## 5.4测试
步骤：

1. 开启缓存功能
2. 使用5.2中的注解即可完成缓存操作
### 5.4.1开启缓存功能
```java
@EnableCaching
```
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711704612934-983a52ad-c771-4695-bb80-8a0d14919866.png#averageHue=%232e2d2c&clientId=uce96c6c3-0642-4&from=paste&height=232&id=ub1f7c65b&originHeight=232&originWidth=767&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26817&status=done&style=none&taskId=ub6661b0e-db8b-4a55-8ccd-3ecddc773c8&title=&width=767)
### 5.4.2 测试注解
#### 5.4.2.1 Cacheable

1. 在方法上加上@Cacheable注解：表明当前的方法结果需要缓存，如果缓存中有，方法不调用；否则调用方法并将方法的结果保存到缓存。
   - value：指定缓存分区，是一个数组，可以放在多个分区。
   -  key：接受一个SpEL, 固定值加单引号。#root.methodName表示取方法名作为key。SpEL表达式参考：[https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html](https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html)

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711706950261-0fbe3ccc-52af-4a98-84f0-696777b591bb.png#averageHue=%2321272d&clientId=uce96c6c3-0642-4&from=paste&height=989&id=yuDpp&originHeight=989&originWidth=1052&originalType=binary&ratio=1&rotation=0&showTitle=false&size=167444&status=done&style=none&taskId=u5244bbc6-b1e0-4612-bf10-d40e975e9fe&title=&width=1052)


```java
    /**
     * @description: 加入SpringCache缓存注解
     * @Cacheable： 代表当前的结果需要缓存，如果缓存中有，方法不用调用，否则调用方法并将方法的结果放入缓存。{"getCatalogJsonByDBUseSpringCache"}指定缓存分区，是一个数组，可以放在多个分区
     * 自定义：
     * 1）指定key: key属性执行，接受一个SpEL,固定值加单引号。#root.methodName表示取方法名作为key。
     * SpEL表达式参考：https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html
     * 2)指定过期时间：配置文件中 spring.cache.redis.time-to-live, 单位ms
     * 3）将数据保存为json格式： 默认使用jdk序列化。将数据保存为json格式涉及自定义缓存管理器。
     *
     * 自定义缓存管理器原理：
     * CacheAutoConfiguration ->导入RedisCacheConfiguration ->自动配置了RedisCacheManager -> 初始化所有的缓存 ->每个缓存决定使用什么配置
     * -> 如果RedisCacheConfiguration有就用已有的，没有就用默认配置
     * -> 想改缓存配置，只需给容器中放一个RedisCacheConfiguration即可
     * -> 就会应用到当前RedisCacheManager管理的所有缓存分区中。
     *
     * 指定序列化方式： keySerializationPair  valueSerializationPair
     **/
    @Cacheable(value = {"product"},key="#root.methodName")
    @Override
    public Map<String, List<Catalog2Vo>> getCatalogJsonByDBUseSpringCache() {
        log.info("查询了数据库");
        Map<String, List<Catalog2Vo>> map = null;  // 结果
        // 找一级分类
        List<CategoryEntity> categoryEntityList = getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", 0));
        if (categoryEntityList != null)
        {
            // 对每一个一级分类找二级分类
            // 封装成map   key=一级分类的catId  value=List<Catalog2Vo>
            map = categoryEntityList.stream().collect(Collectors.toMap(k -> {
                return k.getCatId().toString();
            }, v -> {
                // 找v的二级分类列表
                List<Catalog2Vo> catalog2VoList = null;
                List<CategoryEntity> category2Entities = getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", v.getCatId()));
                if (category2Entities != null)
                {
                    // 将category2Entities封装成List<Catalog2Vo>
                    // 先找3级子分类列表
                    catalog2VoList = category2Entities.stream().map(l2 -> {
                        List<CategoryEntity> category3Entities = getBaseMapper().selectList(new QueryWrapper<CategoryEntity>().eq("parent_cid", l2.getCatId()));
                        List<Catalog2Vo.Category3Vo> category3VoList = null;
                        if (category3Entities != null)
                        {
                            category3VoList = category3Entities.stream().map(l3 -> {
                                Catalog2Vo.Category3Vo catalog3Vo = new Catalog2Vo.Category3Vo(l2.getCatId().toString(), l3.getCatId().toString(), l3.getName());
                                return catalog3Vo;
                            }).collect(Collectors.toList());
                        }
                        Catalog2Vo catalog2Vo = new Catalog2Vo(l2.getParentCid().toString(), category3VoList, l2.getCatId().toString(), l2.getName());
                        return catalog2Vo;
                    }).collect(Collectors.toList());
                }
                return catalog2VoList;
            }));
        }
        return map;
    }
```

自定义：
1）指定key:  接收一个SpEL,固定值加单引号。#root.methodName表示取方法名作为key。 SpEL表达式参考：[https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html](https://docs.spring.io/spring-framework/reference/integration/cache/annotations.html)
2) 过期时间：配置文件中 spring.cache.redis.time-to-live, 单位ms
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711710180063-fcaba87b-cdd2-42a3-802a-06557b135e70.png#averageHue=%23302c2b&clientId=uce96c6c3-0642-4&from=paste&height=203&id=u1a297973&originHeight=203&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32748&status=done&style=none&taskId=ud4adfb68-b81b-48ee-944d-9e4045b5040&title=&width=554)

 3）将数据保存为json格式： 默认使用jdk序列化，将数据保存为json格式涉及自定义缓存管理器。


**自定义缓存管理器原理**：
CacheAutoConfiguration ->导入RedisCacheConfiguration
 ->自动配置了RedisCacheManager -> 初始化所有的缓存 ->每个缓存决定使用什么配置-> 如果RedisCacheConfiguration有就用已有的，没有就用默认配置
 -> 想改缓存配置，只需给容器中放一个RedisCacheConfiguration即可
-> 就会应用到当前RedisCacheManager管理的所有缓存分区中。
指定序列化方式： keySerializationPair  valueSerializationPair

创建配置类：
```java
package com.atguigu.product.config;
import com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.cache.CacheProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;
/**
 * @Author qiang.long
 * @Date 2024/03/29
 * @Description 自定义SpringCache缓存配置
 * @EnableCaching可以从主类移到这里
 *
 * @EnableConfigurationProperties 绑定配置文件
 **/

@EnableConfigurationProperties(CacheProperties.class)
@EnableCaching
@Configuration
public class MyCacheConfig {
    // 会自动从容器中拿到参数CacheProperties cacheProperties
    @Bean
    RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties){
        RedisCacheConfiguration config=RedisCacheConfiguration.defaultCacheConfig();
        config=config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));  // 指定键的序列化方式，都是String
        config=config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericFastJsonRedisSerializer()));  // 指定值的序列化方式，通用json
        // 将application.yml中的配置也导入
        CacheProperties.Redis redisProperties=cacheProperties.getRedis();  // 和redis相关的所有配置
        if (redisProperties.getTimeToLive()!=null){ // 过期时间
            config=config.entryTtl(redisProperties.getTimeToLive());
        }
        if (redisProperties.getKeyPrefix()!=null){ // key前缀
            config=config.prefixKeysWith(redisProperties.getKeyPrefix());
        }
        if (!redisProperties.isCacheNullValues()){ // 是否缓存空值
            config=config.disableCachingNullValues();
        }
        if (!redisProperties.isUseKeyPrefix()){ // 是否使用key前缀
            config=config.disableKeyPrefix();
        }
        return config;
    }
}

```

建议配置文件：
```yaml
spring:
  # Spring Cache
  cache:
    type: redis  #缓存的类型
    redis:
      time-to-live: 60000   #过期时间，单位ms  即1min
      #use-key-prefix: true #使用key前缀
      #key-prefix: CACHE_ #key前缀，表明这是缓存，和redis中的其他数据分开
      cache-null-values: true  #是否缓存空值，防止缓存穿透
```

测试：
```java
/**
     * @description: 使用SpringCache缓存注解
     * @param:
     * @return: Map<List<Catalog2Vo>>
     **/
@GetMapping("/index/springcache/catalog.json")
public Map<String, List<Catalog2Vo>> getCatalogJsonUseSpringCache(){
    log.info("获取二级三级菜单数据");
    return categoryService.getCatalogJsonByDBUseSpringCache();
}
```

发送请求：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711710540314-1825e9a9-6b84-405c-9e7e-9cb733f8ccfa.png#averageHue=%23e2e2e2&clientId=uce96c6c3-0642-4&from=paste&height=296&id=uceaf44c0&originHeight=296&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&size=56279&status=done&style=none&taskId=u1ff323c8-e494-4909-9a30-5c3248c6d25&title=&width=926)

发第一次请求，缓存中没有，查数据库并存入redis;之后不用调用方法，直接返回缓存中的。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711710890470-e64280d0-5a8b-4ca0-a19e-a97201f74636.png#averageHue=%23302e2e&clientId=uce96c6c3-0642-4&from=paste&height=180&id=u83cac5bc&originHeight=180&originWidth=1124&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54866&status=done&style=none&taskId=u21cc6d8c-8d59-4eab-9d97-73e437ace6e&title=&width=1124)
缓存中的数据：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711710963683-82c1ac11-1e41-4dae-a669-13eec5dde583.png#averageHue=%23f4f2f1&clientId=u723dfadb-0860-4&from=paste&height=571&id=ufb1131c7&originHeight=571&originWidth=756&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62108&status=done&style=none&taskId=u1200af8f-c5ba-4599-b7e9-d6ef367e221&title=&width=756)

#### 5.4.2.2 CacheEvict
执行方法触发删除相关缓存
```java
@PostMapping("/update/category")
public String updateCategory(@RequestBody CategoryEntity category){
    return categoryService.updateCategory(category);
}
```

一旦执行updateCategory方法，就会删除相关缓存：
```java
@CacheEvict(value = {"product"},key="'getCatalogJsonByDBUseSpringCache'")
@Override
public String updateCategory(CategoryEntity category) {
    return getBaseMapper().updateById(category)>0?"success":"fail";
}
```

测试：
先发/index/springcache/catalog.json请求确保redis中有缓存
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711712310126-de3048f6-7aa0-4f38-9788-8ad2eb45dd65.png#averageHue=%23f5f3f1&clientId=ubf4994fb-93bb-4&from=paste&height=549&id=u613b75cd&originHeight=549&originWidth=719&originalType=binary&ratio=1&rotation=0&showTitle=false&size=58991&status=done&style=none&taskId=ueda2a352-4050-4a57-9b7b-5ceeda43e81&title=&width=719)
然后修改菜单：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711712344723-022dffe4-c25b-4b72-aa55-5042f83b8ab3.png#averageHue=%23fcfbfa&clientId=ubf4994fb-93bb-4&from=paste&height=337&id=uced6cf09&originHeight=337&originWidth=520&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25313&status=done&style=none&taskId=ue8ec8c21-2dd8-4a58-ba9c-a85aef5d7a8&title=&width=520)
再次查看redis缓存已被删除：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711712372201-41ebaf4b-2921-4f33-b47a-ba208e80aedc.png#averageHue=%23f8f8f8&clientId=ubf4994fb-93bb-4&from=paste&height=173&id=u2debb42d&originHeight=173&originWidth=712&originalType=binary&ratio=1&rotation=0&showTitle=false&size=8681&status=done&style=none&taskId=u119b638e-c594-44d6-85e2-8eaad07379a&title=&width=712)
删除某一分区下的所有缓存：
```java
 @CacheEvict(value = {"product"},allEntries = true)
    public String updateCategory(CategoryEntity category) {
        return getBaseMapper().updateById(category)>0?"success":"fail";
    }
```
**建议：配置文件里不指定分区前缀。且存储同一类型的数据，都指定为相同分区，更新时将该分区下所有缓存全部删掉。**
#### 5.4.2.3 Caching
组合多种缓存操作。
测试场景：执行updateCategory方法同时清空2个缓存。

```java
@Caching(evict = {
            @CacheEvict(value = {"product"},key="'getCatalogJsonByDBUseSpringCache'"),
            @CacheEvict(value = {"product"},key="'getCatalogJsonByDBUseSpringCache123'"),
    })
public String updateCategory(CategoryEntity category) {
    return getBaseMapper().updateById(category)>0?"success":"fail";
}
```


## 5.5 SpringCache的不足

1. 读模式

都做了防御措施

- 缓存穿透：请求的 key **既不存在于缓存中，也不存在于数据库中**。解决：缓存空数据，加上配置cache-null-values: true即可。
- 缓存击穿：请求的 key 是**热点数据，存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）**。解决：**RedisCache加了本地锁synchronized，虽然不能锁住所有线程，但顶多放实例数个线程进来，也大大减轻了数据库压力。**

![image.png](https://cdn.nlark.com/yuque/0/2024/png/34372585/1711714696673-01587a76-b2ff-49a6-a0f7-d0c26c29dc23.png#averageHue=%232e2d2c&clientId=ua5615797-2cf5-4&from=paste&height=573&id=uad5dac29&originHeight=573&originWidth=814&originalType=binary&ratio=1&rotation=0&showTitle=false&size=65726&status=done&style=none&taskId=u84027663-1b60-43f7-8b3b-e443fd1af38&title=&width=814)

- 缓存雪崩：大量key同时过期。解决：加随机时间，加上过期时间。

缓存穿透、缓存击穿、缓存雪崩概念及解决方式参考：[https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F](https://javaguide.cn/database/redis/redis-questions-02.html#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F)


2. 写模式（缓存与数据库一致性）
- 读写加锁：SpringCache没有加锁
- 引入Canal，感知到MySQL的更新去更新数据库
- 读多写多：直接取数据库查询


总结：

1. 常规数据（读多写少，即时性、一致性要求不高的数据）完全可以使用SpingCache。记得加过期时间和缓存null。
2. 特殊数据：特殊设计


